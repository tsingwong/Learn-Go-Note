# 《GO 语言学习笔记》学习笔记

### 第一章 概述

1.  可以用  `defer` 定义延迟调用，无论函数是否出错，它都会确保结束前调用。

-   常用来释放资源、解除锁定、或执行一些清理操作

-   可以定义多个 defer，按照 FILO （先进后出，栈）执行

```go
package main

func test(a, b int) {
	defer println("dispose>>>")

	println(a / b)
}

func main() {
	test(10, 0)
}
```



2.  `ok-idiom`模式，是指在多返回值中用一个名为 ok 的布尔值来表示操作是否成功。因为很多操作默认返回**零值**，所需需要额外说明。
3.  结构体 `struct` 可以匿名嵌入其他类型，也可以调用匿名字段的方法，多用于实现与继承类似的功能

```go
package main

import "fmt"

type user struct {
	name string
	age  byte
}

func (u user) ToString() string {
	return fmt.Sprintf("%+v", u)
}

type manage struct {
	user
	title string
}

func main() {
	var m manage
	m.name = "tsingwong"
	m.age = 29
	fmt.Println(m.ToString())
}
```

4.  **并发** ：整个运行时完全并发化设计，几乎都是在以 `goroutine`方式运行。这是一种比普通协程或线程更加高效的并发设计，能轻松创建和运行成千上万的并发任务。

### 第二章 类型

1.  Go 是一门静态语言，类型决定了变量内存的长度和储存格式。一经创建只能修改变量的值，无法改变类型。
2.  关键词 `var` 用于定义变量，类型放在变量名后，运行时内存分配操作会确保变量自动初始化为二进制零值，避免出现不可预期的行为。未使用的局部变量会引发编译错误。

简短模式的弊端：

-   定义变量，同时显示初始化
-   不能提供数据类型
-   只能用于函数内部（`var`可以用在全局作用域）

```go
var a int
var b, c int
var d, e = 100, "tsingwong"
var (
	f, g int
    h, i = 100, "tsingwong"
)

// 简短模式
j := 100
h, i = 1, "tsingwong"
```

3.  多变量赋值操作时，首先会计算出所有右边值，然后再依次完成赋值操作。赋值操作，必须确保左右值类型一致。
4.  变量命名：以字母或下划线开始，可以由多个字母、数字和下划线组成；区分大小写；使用驼峰（camel case）拼写。首字母大小写决定了其作用域，首字母大写即为可导出成员，可以被包外引用，反之小写只能在包内使用。[推荐命名查询网站](https://unbug.github.io/codelf/)
5.  `_` 空标识符：通常用作忽略用的占位符，可以作为表达式左值，无法读取其内容。多用来临时规避编译器对未使用变量和导入包的错误检查。
6.  常量：必须是编译器可确定的字符、字符串、数字或布尔值。不曾使用的常量不会引发编译错误。显式指定类型时，必须确保常量左右值类型一致。常量组中不指定类型和初始值，则与上一行的非空常数右值相同。
7.  Go 语言中没有明确意义上的 `enum` 定义，即枚举，可以借助 `iota` 标识符来实现自增常量的枚举类型。 `iota` 中断自增后，需要显式恢复，且后续自增值按行序递增。

```go
const(
	a = iota 	// 0
    b		 	// 1
    c = 100		// 100
    d			// 100
    e = iota	// 4
    f			// 5
)
```

